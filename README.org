#+title: A simple lisp micro-service 
#+author:  Spike Spiegel

* Introduction
The idea behind this project is to create and deploy a simple interface based on LISP on Kubernetes. Completely crazy? Probably ;-) 
The second idea is simply to convert my /go-video-api/ on LISP, so...
And finally, a piece of security for fun...
* State of Art
** Istio
It is possible to intercept and modify data passing between two services, but not directly at the raw byte level like a low-level filter (e.g., a raw TCP proxy). Istio operates primarily at the HTTP/gRPC level (layer 7 of the OSI model), which means that you can manipulate headers and the body of requests/responses, but not each individual byte.
** Customize proxy
If you need very fine-grained control (for example, modifying each byte), you can replace the Envoy sidecar with a custom proxy (written in Go, Rust, etc.) that implements the desired filtering logic.
** Istio and eBPF
For truly low-level control (layer 4), you can combine Istio with tools such as Cilium (which uses eBPF) to intercept and modify network traffic. However, this goes beyond Istio's native scope.
** Summary
* Podman
Just to be true to myself, I'll use /podman/. Now, let's start the virtual machine.
#+begin_src shell
$ podman machime start
$ podman info
#+end_src
* Process
** Run
To test the application without stress, I created this smart script.
** Build Script explanation
Just an overview of the script to build the binary
** How to Build
To simplify the process, I proposed to build in the first step /yano-bin/ in order to push the image as simple as possible through a basic /Dockerfile/.
#+begin_src shell
$ sbcl --script build.lisp
#+end_src
* Image
** Dockerfile
I said previously that the best and lazy solution was to build in first the /binary/, so I stay on this inflexible position.
We don't forget to select the right architecture (Linux/AMD), hence the need to compile in a clean container and then create the image.
** Build
Pretty simple,
#+begin_src shell
$ podman build -t gandalfthewhite/yano-bin:latest .
$ podman push localhost/gandalfthewhite/yano-bin:latest  docker.io/gandalfthewhite/yano-bin:latest
#+end_src
** Push
It's time to push our new image
#+begin_src shell
$ podman push gandalfthewhite/yano-bin:latest 
#+end_src
Write your personal name obviously. (ex: gandalfthewhite/yano-bin:latest, just for me)
* Micro-service
** Manifest
To deploy, quite simple, so we just have to understand the order. So. let's get started.
I propose to cut or dissociate the different manifests according to their role.
+ namespace (namespace.yml)
+ deployment (deployment.yml)
+ gateway (gateway.yml)
+ virtual service (virtualservice.yml)
Much better to understand the architecture of the cloud native explanation.
#+begin_src shell
$ kubectl apply -f namespace.yml
$ kubectl apply -f deployment.yml
$ kubectl apply -f gateway.yml
$ kubectl apply -f virtualservice.yml
#+end_src
