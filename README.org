#+title: A simple lisp micro-service 
#+author:  Spike Spiegel

* Introduction
The idea behind this project is to create and deploy a simple interface based on LISP on Kubernetes. Completely crazy? Probably ;-) 
The second idea is simply to convert my /go-video-api/ on LISP, so...
* Process
** Run
To test the application without stress, I created this smart script.
#+begin_src emacs-lisp
#!/usr/bin/env sbcl --script

;;; 1. Load quicklisp
(eval-when (:execute)
  (let ((quicklisp-init (merge-pathnames "quicklisp/setup.lisp" (user-homedir-pathname))))
    (unless (probe-file quicklisp-init)
      (error "Quicklisp not found. Please install Quicklisp first."))
    (load quicklisp-init)))

;;; 2. Load dependencies
(ql:quickload '(:hunchentoot :easy-routes :djula))
(push (uiop:getcwd) asdf:*central-registry*)

;;; 3. Load the system
(ql:quickload "yano")

;;; 4. Start the server
(let ((port (or (and (uiop:command-line-arguments)
                     (parse-integer (first (uiop:command-line-arguments)) :junk-allowed t))
                8899)))
  (handler-case
      (progn
        (yano:start-server :port port)
        ;; Wait signal to stop (Ctrl+C)
        (loop (sleep 1)))
    (error (e)
      (format *error-output* "~&Error: ~a~&" e)
      (sb-ext:exit :code 1))))
#+end_src
** Build Script explanation
Just an overview of the script to build the binary
#+begin_src emacs-lisp
#!/usr/bin/env sbcl --script

;; Load the quicklisp environment
(eval-when (:execute)
  (let ((quicklisp-init (merge-pathnames "quicklisp/setup.lisp" (user-homedir-pathname))))
    (unless (probe-file quicklisp-init)
      (error "Quicklisp not found. Please install Quicklisp first."))
    (load quicklisp-init)))

;; Load system and dependencies
;; and include the working directory
(ql:quickload '(:hunchentoot :easy-routes :djula))
(push (uiop:getcwd) asdf:*central-registry*)
(ql:quickload "yano")

;; Create the directory if not
;; Pretty simple to understand
(defun ensure-build-dir ()
  (let ((build-dir (merge-pathnames "build/" (uiop:getcwd))))
    (unless (uiop:directory-exists-p build-dir)
      (ensure-directories-exist build-dir)
      (format t "'build' Directory created.~%"))))

;; Main function
(defun main ()
  (let ((*package* (find-package :yano)))
    (yano::start-server)
    (sleep most-positive-fixnum)))

;; We test and create if not
(ensure-build-dir)

;; Save binary in the build directory
(sb-ext:save-lisp-and-die
 (merge-pathnames "build/yano-bin" (uiop:getcwd))
 :toplevel #'main
 :executable t
 :compression t)
#+end_src
** How to Build
To simplify the process, I proposed to build in the first step /yano-bin/ in order to push the image as simple as possible through a basic /Dockerfile/.
#+begin_src shell
$ sbcl --script build.lisp
#+end_src
* Image
** Dockerfile
I said previously that the best and lazy solution was to build in first the /binary/, so I stay on this inflexible position.
#+begin_src emacs-lisp
# syntax=docker/dockerfile:1

FROM --platform=linux/amd64 debian:12-slim AS build-stage

ENV DEBIAN_FRONTEND=noninteractive
ENV SBCL_VERSION=2.3.9

# Dépendances système
RUN apt-get update && apt-get install -y \
curl \
ca-certificates \
build-essential \
libssl-dev \
zlib1g-dev \
&& rm -rf /var/lib/apt/lists/*

# Installer SBCL
RUN curl -L https://downloads.sourceforge.net/project/sbcl/sbcl/${SBCL_VERSION}/sbcl-${SBCL_VERSION}-x86-64-linux-binary.tar.bz2 \
| tar -xj \
&& cd sbcl-${SBCL_VERSION}-x86-64-linux \
&& sh install.sh \
&& cd / \
&& rm -rf sbcl-${SBCL_VERSION}-x86-64-linux

# Installer Quicklisp
RUN curl -O https://beta.quicklisp.org/quicklisp.lisp \
&& sbcl --non-interactive \
--load quicklisp.lisp \
--eval '(quicklisp-quickstart:install)' \
--eval '(ql-util:without-prompting (ql:add-to-init-file))' \
--eval '(quit)' \
&& rm quicklisp.lisp

# Copier le projet
WORKDIR /app
COPY . /app

# Construire le binaire
RUN sbcl --script build.lisp

FROM --platform=linux/amd64 gcr.io/distroless/base-debian12

ENV PORT=4242

WORKDIR /app
COPY --from=build-stage /app/build/yano-bin /app/yano-bin

EXPOSE $PORT
ENTRYPOINT ["/app/yano-bin"]
#+end_src
** Build
Pretty simple,
#+begin_src shell
$ podman build -t $(USER)/yano-bin:latest .
#+end_src
** Push
It's time to push our new image
#+begin_src shell
$ podman push $(USER)/yano-bin:latest 
#+end_src
Write your personal name ($USER) obviously.
* Micro-service
** Manifest
Actually, the /manifest/ is normal without any difference, we just have to select the right image.
** Deploy
