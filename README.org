#+title: A simple lisp micro-service 
#+author:  Spike Spiegel

* Introduction
The idea behind this project is to create and deploy a simple interface based on LISP on Kubernetes. Completely crazy? Probably ;-) 
The second idea is simply to convert my /go-video-api/ on LISP, so...
And finally, a piece of security for fun...
* State of Art
** Istio
It is possible to intercept and modify data passing between two services, but not directly at the raw byte level like a low-level filter (e.g., a raw TCP proxy). Istio operates primarily at the HTTP/gRPC level (layer 7 of the OSI model), which means that you can manipulate headers and the body of requests/responses, but not each individual byte.
** Customize proxy
If you need very fine-grained control (for example, modifying each byte), you can replace the Envoy sidecar with a custom proxy (written in Go, Rust, etc.) that implements the desired filtering logic.
** Istio and eBPF
For truly low-level control (layer 4), you can combine Istio with tools such as Cilium (which uses eBPF) to intercept and modify network traffic. However, this goes beyond Istio's native scope.
** Summary
* Process
** Run
To test the application without stress, I created this smart script.
** Build Script explanation
Just an overview of the script to build the binary
** How to Build
To simplify the process, I proposed to build in the first step /yano-bin/ in order to push the image as simple as possible through a basic /Dockerfile/.
#+begin_src shell
$ sbcl --script build.lisp
#+end_src
* Image
** Dockerfile
I said previously that the best and lazy solution was to build in first the /binary/, so I stay on this inflexible position.
We don't forget to select the right architecture (Linux/AMD), hence the need to compile in a clean container and then create the image.
** TODO Build
Pretty simple,
#+begin_src shell
$ docker build --platform linux/amd64 -t gandalfthewhite/cl-proxy:latest -f Dockerfile-proxy .
$ docker push localhost/gandalfthewhite/cl-proxy:latest  docker.io/gandalfthewhite/cl-proxy:latest
#+end_src
** Push
It's time to push our new image
#+begin_src shell
$ podman push gandalfthewhite/yano-bin:latest 
#+end_src
Write your personal name obviously. (ex: gandalfthewhite/yano-bin:latest, just for me)
* Micro-service
** Manifest
To deploy, quite simple, so we just have to understand the order. So. let's get started.
I propose to cut or dissociate the different manifests according to their role.
+ namespace (namespace.yml)
+ deployment (deployment.yml)
+ gateway (gateway.yml)
+ virtual service (virtualservice.yml)
Much better to understand the architecture of the cloud native explanation.
#+begin_src shell
$ kubectl apply -f namespace.yml
$ kubectl apply -f deployment.yml
$ kubectl apply -f gateway.yml
$ kubectl apply -f virtualservice.yml
#+end_src

* Test
** Simple
#+begin_src shell
$ ./build/yano-frontend-bin 8000 "http://127.0.0.1:9000"
$ ./build/yano-backend-bin 9000 "http://192.188.200.55"
#+end_src
** Only one proxy
We just have only one proxy
+ Frontend
  #+begin_src shell
$ ./build/yano-frontend-bin 8000 "http://127.0.0.1:45000"
  #+end_src
+ Proxy first
  #+begin_src shell
$ ./build/yano-proxy-bin 45000 "127.0.0.1" 9000 "0.0.0.0" "alone"
  #+end_src
+ Backend
  #+begin_src shell
$ ./build/yano-backend-bin 9000 "http://192.188.200.55"
  #+end_src
** 2 serial proxies
We suppose to srat frontend, proxy 1 and 2, and finally backend on the same computer. The HLS server is on a different server
+ Frontend
  #+begin_src shell
$ ./build/yano-frontend-bin 8000 "http://127.0.0.1:45000"
  #+end_src
+ Proxy first
  #+begin_src shell
$ ./build/yano-proxy-bin 45000 "127.0.0.1" 45001 "0.0.0.0" "client"
  #+end_src
+ Proxy second
  #+begin_src shell
$ ./build/yano-proxy-bin 45001 "127.0.0.1" 9000 "0.0.0.0" "server"
  #+end_src
+ Backend
  #+begin_src shell
$ ./build/yano-backend-bin 9000 "http://192.188.200.55"
  #+end_src
* Virtual machine
** Frontend server
#+begin_src shell
$ ./build/yano-frontend-bin 8000 "http://192.188.200.57:9000"
#+end_src
** Frontend proxy
#+begin_src shell
$ ./build/yano-proxy-bin 45000 "192.188.200.57" 9000
#+end_src
** Backend server
#+begin_src shell
$ ./build/yano-backend-bin 9000 "http://192.188.200.55"
#+end_src
** Backend proxy
#+begin_src shell
$ ./build/yano-proxy-bin 45001 "127.0.0.1" 9000
#+end_src
* Iptables
** Frontend
We must be sure that /proxy/ is started with the /spike/ account
#+begin_src shell
$ iptables -t nat -A OUTPUT -p tcp -m owner --uid-owner spike -j RETURN
$ iptables -t nat -A OUTPUT -p tcp -m owner ! --uid-owner spike --dport 9000 -j REDIRECT --to-port 45000
#+end_src
** Backend
#+begin_src shell
$ iptables -t nat -I PREROUTING 1 -p tcp -m addrtype --dst-type LOCAL --dport 9000 -j REDIRECT --to-ports 45001
#+end_src
and locally
#+begin_src shell
$ iptables -t nat -I OUTPUT 1 -p tcp -m owner --uid-owner spike -j RETURN
$ iptables -t nat -I OUTPUT 2 -p tcp --dport 9000 -j REDIRECT --to-ports 45001
#+end_src
** Check
#+begin_src shell
$ ss -lntp | egrep ':9000|:45001'
LISTEN 0      128          0.0.0.0:45001      0.0.0.0:*    users:(("yano-proxy-bin",pid=4831,fd=4))
LISTEN 0      50           0.0.0.0:9000       0.0.0.0:*    users:(("yano-backend-bi",pid=4697,fd=4))
#+end_src
and
#+begin_src shell
$ iptables -t nat -L PREROUTING -n -v --line-numbers
Chain PREROUTING (policy ACCEPT 1 packets, 88 bytes)
num   pkts bytes target     prot opt in     out     source               destination
1        9   540 REDIRECT   6    --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL tcp dpt:9000 redir ports 45001
#+end_src
* Oracle
** Sing
It's just a simple server
#+begin_src shell
$ ./build/yano-oracle-bin 9100
#+end_src
** Proxy
The P1 proxy
#+begin_src shell
$ ./build/yano-proxy-bin 45000 "127.0.0.1" 45001 "127.0.0.1" 9100 "0.0.0.0" "p1"
#+end_src
** Proxy
The P2 proxy
#+begin_src shell
$ ./build/yano-proxy-bin 45001 "127.0.0.1" 9000 "127.0.0.1" 9100 "0.0.0.0" "p2"
#+end_src
** Frontend
#+begin_src shell
$ ./build/yano-frontend-bin 8000 "http://127.0.0.1:45000"
#+end_src
** Backend
#+begin_src shell
$ ./build/yano-backend-bin 9000 "http://192.188.200.55"
#+end_src
Et voila..
* New Version
